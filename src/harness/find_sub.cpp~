#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <math.h>
#include "lsq.h"
#include "sub.h"

bool same_vars(int* list1, int* list2, int n) {
  bool same=true;
  for(int i=0; i<n; i++) {
    if(list1[i] != list2[i]) {
      same = false;
      return same;
    }
  }
  return same;
}

void shell(int* l, int n) {
  int finish, temp, new_value, i1, i2, incr, it;
  incr = n;
  while(incr > 1) {
    incr = incr/3;
    if(incr == 2*(incr/2)) incr++;
    for(int i=0; i<incr; i++) {
      finish = n;
      while(finish > incr) {
	i1 = i;      
	temp = l[i1];
	it = i1;
	for(i2=i1+incr; i2<finish+incr; i2+=incr) {
	  new_value = l[i2];
	  if(temp > new_value) {
	    l[i1] = new_value;
	    i1 = i2;
	    continue;
	  }
	  if(i1 > it) l[i1] = temp;  
	  i1 = i2;
	  temp = new_value;
	  it = i1;
	}
	if(i1 > it) l[i1] = temp;
	finish = finish-incr;
      }
    }
  }
}

void report(int nv, double ssq, int max_size, double* bound, int nbest, double** ress, int* vorder, int** lopt) {
  int pos1, lists[nv], lists2[nv];
  double under1 = 0.99999999, above1 = 1.00000001;

  if(nv > max_size) return;
  if(ssq >= bound[nv]) return;
  pos1 = (nv*(nv-1))/2;

  // Find rank of the new subset
  for(int rank=0; rank<nbest; rank++) {
    if(ssq < (ress[nv][rank])*above1) {
      for(int j=0; j<nv; j++) {
	lists[j] = vorder[j];
      }
      shell(lists, nv);
      if(ssq > ress[nv][rank]*under1) {
	for(int i=0; i<nv; i++) {
	  lists2[i] = lopt[pos1+i][nv];
	}
	if(same_vars(lists, lists2, nv)) break;
      }
      for(int j=nbest-1; j>rank; j--) {
	ress[nv][j] = ress[nv][j-1];
	for(int k=pos1; k<pos1+nv-2; k++) {
	  lopt[k][j+1] = lopt[k][j];
	}
      }
      ress[nv][rank] = ssq;
      for(int k=0; k<nv; k++) {
	lopt[k+pos1][rank] = lists[k];
	bound[nv] = ress[nv][nbest];
      }
      break;
    }
  }
}

void init_subsets(int cols, int nvar_max, bool fit_const, int nbest, double* work, double* r, double* tol, bool* tol_set, double* D, int* row_ptr, double* rhs, double* sserr, bool* rss_set, double* rss, int* vorder) {
  double eps = 1e-14;
  double vlarge = 3.4028e38;
  bool lindep[cols];
  int ier, max_size, lopt_dim1, ifault[1];
  lopt_dim1 = max_size*(max_size+1)/2;
  if(fit_const) {
    max_size = nvar_max+1;
  } else {
    max_size = nvar_max;
  }
  double bound[max_size];
  double **ress = new double*[max_size]; // Input matrix
  for(int i=0; i<max_size; i++) {
    bound[i] = vlarge;
    ress[i] = new double[nbest];
    for(int j=0; j<nbest; j++) {
      ress[i][j] = vlarge;
    }
  }

  int **lopt = new int*[lopt_dim1];
  for(int i=0; i<lopt_dim1; i++) {
    for(int j=0; j<nbest; j++) {
      lopt[i][j] = 0;
    }
  }
  tolset(cols, work, r, tol, tol_set);
  sing(lindep, ifault, cols, D, tol_set, r, tol, row_ptr, rhs, sserr, work);
  
  ss(cols, sserr, rss, rss_set, D, rhs);
  for(int i=0; i<max_size; i++) {
    report(i, rss[i], max_size, bound, nbest, ress, vorder, lopt);
   }
}
