#include <stdio.h>
#include <stdlib.h>
#include <iostream>
#include <fstream>
#include <sstream>
#include <math.h>
#include "lsq.h"
#include "sub.h"

/****************************************************************************************************
bsauk 4/18

While developing, this function is used to test the functions I am implementing for subset selection.
These functions will serve as an accuracy comparison later on when developing parallel algorithms.
Initial comparison is with the Fortran algorithms that Alan Miller provided on his website. 

I will try to use simple examples that test the conditionals of every algorithm being developed.

******************************************************************************************************/

#define MAXVAR 30 // Problem specific, number of variables in equation can adjust these values
#define MAXCASES 500 // Problem specific, number of trials

void subset_gold(double** A, double* weights, double* y, int rows, int cols, int nbest, int nvar_max) {
  int nvar = cols, nobs = 0, in, r_dim = cols*(cols-1)/2, max_cdim = MAXVAR*(MAXVAR+1)/2;
  double sserr[1], D[cols], r[r_dim], rss[cols], rhs[cols], xrow[cols+1], work[cols], tol[cols], ycorr[MAXVAR], cormat[max_cdim], beta[MAXVAR], xx[MAXVAR];
  double sterr[MAXVAR];
  int vorder[cols], row_ptr[cols], ifault[1], list[4];
  bool lindep[cols], tol_set[1], rss_set[1], fit_const[1];
  double vsmall = 2.225e-307;
  double t[MAXVAR], fitted, resid[MAXCASES], std_resid[MAXCASES], hii[1], std_err_pred, covmat[max_cdim];

  for(int i=0; i<cols; i++) {
    vorder[i] = i;
  }
  row_ptr[0] = 0;
  for(int i=1; i<cols; i++) {
    row_ptr[i] = row_ptr[i-1] + cols - i; 
  }

  init_subsets(cols, nvar_max, fit_const, nbest, work, r, tol, tol_set, D, row_ptr, rhs, sserr, rss_set, rss, vorder);
}

int main(int argc, char* argv[]) {
    std::cout.precision(16); //16 digit precision to match up with Fortran implementation move to header

  // Error handling for # of inputs  
  if(argc == 1) {
    std::cout << "Please provide .dat file and number of rows, cols, nbest, and max. subset size!" << std::endl;
    return 0;
  }
  if(argc == 2) {
    std::cout << "Please provide number of rows, cols, nbest, and max. subset size!" << std::endl;
    return 0;
  }
  if(argc == 3){
    std::cout << "Please provide number of cols, nbest, and max. subset size!" << std::endl;
    return 0;
  }
  if(argc == 4) {
    std:: cout << "Please provide nbest, and max. subset size!" << std::endl;
  }
  if(argc == 5) {
    std:: cout << "Please provide max. subset size!" << std::endl;
  }
  if(argc > 6) {
    std:: cout << "Too many arguments please only provide file name, rows, cols, nbest, and max. subset size" << std::endl;
  }

  // This part reads in the input file using the # of rows and columns
  const int rows = atoi(argv[2]);
  const int cols = atoi(argv[3])+1;
  const int nbest = atoi(argv[4]);
  const int nvar_max = atoi(argv[5]);
  // If fit_constant true, which i'm assuming for now add 1 to cols
  double **A = new double*[rows]; // Input matrix
  double A2[rows][cols]; //Input matrix for other methods
  double y[rows];
  double weights[rows];
  double b[rows]; // Output vector for Ax = b for other algorithms  
  
  std::ifstream file;
  file.open(argv[1]);
  for(int i=0; i<rows; i++) {
    A[i] = new double[cols];
    for(int j=0; j<cols+1; j++) {
      if(j<cols-1) {
	file >> A[i][j];
	A2[i][j] = A[i][j];
      } else if(j==cols-1) {
	file >> weights[i];
      } else {
	file >> y[i];
	b[i] = y[i];
      }
    } 
  }
  file.close();
  //Subset
  subset_gold(A, weights, y, rows, cols, nbest, nvar_max);
  return 0;
}



